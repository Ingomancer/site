+++
date = 2024-11-26T05:26:12Z
draft = true
title = "Kodsnack 612 - Where types first come in, with Pedro Abreu"
slug = "612"
aliases = ["/blog/2024/11/26/612"]
categories = ["avsnitt"]
audiofile = "https://traffic.libsyn.com/kodsnack/612.mp3"
libsynid = "34137491"
english = true
audiosize = "27154640"
audiolength = "55:53"
people = ["Fredrik Björeman", "Pedro Abreu"]
sponsor = [""]
images = ["avsnitt/612/612-cover.png"]
+++

Fredrik talks to [Pedro Abreu](https://pedroabreu0.github.io/) about the magical world of type theory. What is it, and why is it useful to know about and be inspired by?

Pedro gives us some background on type theory, and then we talk about how type theory can provide new ways of reasoning about programs, and tools beyond tests to verify program correctness. This doesn't mean that all languages should strive for the nirvana of dependent types, but knowing the tools are out there can come in handy even if the code you write is loosely typed.

We wrap up with some further podcast tips, of course including Pedro's own podcast Type theory forall.

Thank you [Cloudnet](http://www.cloudnet.se) for sponsoring our [VPS](http://en.wikipedia.org/wiki/Virtual_private_server)!

Comments, questions or tips? We a	re [@kodsnack](https://www.twitter.com/kodsnack), [@tobiashieta](https://www.twitter.com/tobiashieta), [@oferlund](https://twitter.com/oferlund) and [@bjoreman](https://www.twitter.com/bjoreman) on Twitter, have a [page on Facebook](https://www.facebook.com/kodsnack) and can be emailed at [info@kodsnack.se](mailto:info@kodsnack.se) if you want to write longer. We read everything we receive.

If you enjoy Kodsnack we would love a [review in iTunes](http://itunes.apple.com/se/podcast/kodsnack/id561631498?l=en)! You can also support the podcast by <a href="https://ko-fi.com/kodsnack" rel="payment">buying us a coffee (or two!) through Ko-fi</a>.

## Links ##
* [Pedro](https://pedroabreu0.github.io/)
* [Type theory](https://en.wikipedia.org/wiki/Type_theory)
* [Type theory forall](https://www.typetheoryforall.com/) - Pedro's podcast
* [Chalmers](https://en.wikipedia.org/wiki/Chalmers_University_of_Technology)
* [The meetup group](https://www.meetup.com/got-lambda/events/302872130/) through which Pedro and Fredrik met
* [Purdue university](https://en.wikipedia.org/wiki/Purdue_University)
* [Bertrand Russell](https://en.wikipedia.org/wiki/Bertrand_Russell)
* [The problem of self reference](https://en.wikipedia.org/wiki/Self-reference#In_logic,_mathematics_and_computing)
* [Types](https://en.wikipedia.org/wiki/Data_type)
* [Set theory](https://en.wikipedia.org/wiki/Set_theory)
* [Kurt Gödel](https://en.wikipedia.org/wiki/Kurt_G%C3%B6del)
* [Halting problem](https://en.wikipedia.org/wiki/Halting_problem)
* [Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing)
* [Turing machine](https://en.wikipedia.org/wiki/Turing_machine)
* [Alonzo Church](https://en.wikipedia.org/wiki/Alonzo_Church)
* [Lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)
* [Rust](https://en.wikipedia.org/wiki/Rust_%28programming_language%29)
* [Dependent types](https://en.wikipedia.org/wiki/Dependent_type)
* [Formal methods](https://en.wikipedia.org/wiki/Formal_methods)
* [Liquid types - Haskell extension](https://ucsd-progsys.github.io/liquidhaskell/)
* [SAT solver](https://en.wikipedia.org/wiki/SAT_solver)
* [Property-based testing](https://hypothesis.works/articles/what-is-property-based-testing/)
* [Quickcheck](https://en.wikipedia.org/wiki/QuickCheck)
* [Curry-Howard isomorphism](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)
* [Support Kodsnack on Ko-fi!](https://ko-fi.com/kodsnack)
* [Functional programming](https://en.wikipedia.org/wiki/Functional_programming)
* [Imperative programming](https://en.wikipedia.org/wiki/Imperative_programming)
* [Object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming)
* [Monads](https://en.wikipedia.org/wiki/Monad_%28functional_programming%29)
* [Monad transformers](https://en.wikipedia.org/wiki/Monad_transformer)
* [Lenses](https://tech.fpcomplete.com/haskell/tutorial/lens/)
* [Interactive theorem provers](https://en.wikipedia.org/wiki/Proof_assistant)
* [Isabelle](https://en.wikipedia.org/wiki/Isabelle_%28proof_assistant%29)
* [HOL](https://en.wikipedia.org/wiki/HOL_%28proof_assistant%29)
* [Dafny](https://en.wikipedia.org/wiki/Dafny)
* [Saul](https://github.com/CogComp/saul)
* [Crucible](https://github.com/GaloisInc/crucible)
* [Symbolic execution](https://en.wikipedia.org/wiki/Symbolic_execution)
* [CVC3](https://cs.nyu.edu/acsys/cvc3/), [CVC5](https://cvc5.github.io/) solvers
* [Pure functions](https://en.wikipedia.org/wiki/Pure_function)
* [C#](https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29)
* [Algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type)
* [Pattern matching](https://en.wikipedia.org/wiki/Pattern_matching)
* [Scala](https://en.wikipedia.org/wiki/Scala_%28programming_language%29)
* [Recursion](https://en.wikipedia.org/wiki/Recursion)
* [Type theory forall episode 17: the first fantastic one with Conal Elliot](https://www.typetheoryforall.com/episodes/the-lost-elegance-of-computation). The discussion continues in [episode 21](https://www.typetheoryforall.com/episodes/denotational-design)
* [Denotational types](https://en.wikipedia.org/wiki/Denotational_semantics#Denotations_of_data_types)
* [Coq](https://en.wikipedia.org/wiki/Coq_%28software%29)
* [IRC](https://en.wikipedia.org/wiki/IRC)
* [Software foundations - about Coq and a lot more](https://softwarefoundations.cis.upenn.edu/lf-current/toc.html)
* [The church of logic podcast](https://www.youtube.com/playlist?list=PLp0rGqHGDBtMcV6HqLkUa-PihSgAOAInw)
* [The Iowa type theory commute podcast](https://homepage.cs.uiowa.edu/~astump/ittc.html)

## Titles ##
* Type theory podcasts
* Very odd for some people
* Brazilian weather
* Relearning to appreciate
* The dawn of computer science
* Layers of sets
* Where types first come in
* Bundle values together
* The research about programming languages
* If you squint your eyes enough
* Nirvana of type systems
* Proofs all the way down
* Extra guarantees
* If your domain is infinite
* Formal guarantees
* The properties of my system
* What is the meaning of my program?
* Building better systems